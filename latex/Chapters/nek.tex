% Chapter 4 - Description of nek

\chapter{Application of Nek5000} % Main chapter title

\label{nek} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

\lhead{Chapter 4. \emph{application of Nek}} % Change X to a consecutive number; this is for the header on each page - perhaps a shortened title

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------
\colorbox{green}{Some introduction about flow solvers in general and how Nek differs from these}
There are many numerical solvers for turbulent flows available on the market.
From large commercial softwares such as Fluent which runs as a 
black-box solver, to full open-source codes such as nek5000 and openFOAM. 
The solvers can vary both in the fundamental numerical method (FV,FD,FEM,SEM), 
the time-step method (Fractional Step, Poisson pressure, Uzawa) 
and the type of simulation (RANS,LES,DNS).

%An example is waterflow in a channel, which would be the practical problem. 
%The mathematical formulation would be the incompressible N-S eq, 
%with LES dynamical SGS. The mesh could consist of tetrahedros or hexahedrons.
%The simulation is the performed on some cluster before the 
%wanted data in some sub-domain is visualized and presented. 

\section{Nek5000 Basics}
\colorbox{green}{this whole section needs rewriting}

Nek5000 is a turbulent flow solver developed mainly by Paul Fischer
and has through the past 20 years had several contributours. 
It is an open-source code applicable to many different types of flow 
and it has been put a lot of effort into making the code as parallelizable as possible.
With SEM as the numerical method applied it is possible to obtain extremely accurate results.  

nek5000 has its own mesh-generator for generating simpler geometries and it is also implemented the possibility to integrate CUBIT mesh 
files. A common starting point for simulating turbulent flow is a geometry given by a CAD-file,
without any functions to describe the boundaries.
The possibility to make a mesh through a visual gui is provided through for instance ICEM.
This mesh can then later be transformed to the inputfile required by nek5000. 

So far nek5000 has supported three automatic routine for generating curved edges;
circles in 2-D geometries, spherical shell elements and a general 2nd degree interpolation.
Further manipulation of the element edges is left to the user to define manually
for each particular problem. One of the objectives of this thesis is to make Nek5000 more
user-friendly and create automatic routines to handle complex geometry.

In order to get a quick overview of the framework in Nek a short list of the main steps
are stated in the list below 

%
\begin{enumerate}
    \item \emph{Initialize} 
    \subitem Reading mesh and parameters from user, generating GLL-points, and defining
        the values needed to perform the simulations. PRESSURE SOLV INIT ??? 
    \item \emph{solve}
     \subitem Solving for each timestep, depending on the problem solvers for flow,temperature 
     and other scalars will be performed. The user is free to choose different solvers which 
     will be discussed later.
 \item \emph{post-processing}
     \subitem Writing statistics and other user-specified parameters to file.
\end{enumerate}
%
Nek provides a basic tool for generation of mesh. For more complex geometries this tool cannot compare with more visualized-based softwares 
such as ICEM from ANSYS which exports mesh to several numerical solvers such as Fluent and nastran.
It is therefore very useful to have an automatic way of converting a mesh created in ICEM to the format required by nek5000. 
In order for nek to run optimally the elements should be as homogenous and as similar to the reference element as possible. 
It is therefore of great interest to be able to propagate curved geometries into the neighbour-elements in order to have a smooth as 
possible transition from a boundary with high curvature.

\section{User-defined files}
In order to work with Nek there are some practical information that needs to be clarified.
Nek is recompiled for every case and the user specify all the information in the three files \verb|{.rea,.usr,SIZE}|.
%
\subsection{SIZE}
Since Nek is mostly based on Fortran77 all memory allocations are done statically and needs to be specified explicitly 
before runtime. Most of these variables are stated in \verb|SIZE|. Polynomial degree, \#max elements, \#max processors, 
\#max scalars are all examples of variables that are stated in this file. These variables defines the sizes of almost all 
the arrays used in the program so it is important to define these variables as accurately as possible in order to optimize
memory usage.
%
\subsection{.rea}
In \verb|.rea| all the problem specific parameters are given. The strucuture of the file is given in table~\ref{tab:reafile}.
Of the 103 variables specified in the beginning of the file there are roughly 50 of them that are used. Example of the variables
are DT,NSTEPS,IOSTEP which denotes the target time step, total number of steps and the frequency of writing data to file. 
There are also some physical variables such as VISCOS, RHOCP, DENSITY denoting the viscousity of the fluid, convectional constant and 
the density. In addition tolerances, cfl-number, order of discretization, preconditioner and de-aliasing info are also defined in this section.
Of the remaining variables the user can define problem-specific parameters that can be applied in user-defined routines in \verb|.usr|.
%
\begin{table}
    \centering
    \begin{tabular}{c c l}[h]
       Lines & Section Name & Specifications \\ \hline
       $103$ & PARAMETERS & All problem-specific variables \\ 
       $K$ & Passive scalar data & Convective and diffusive constants for scalars\\ 
       $K$ & LOGICAL SWITCHES & Boolean variables defining the solution method \\ 
       $E$ & MESH DATA & All nodes and elements are specified here\\
       $E$ & CURVED SIDE DATA & All the curved sides are specified here\\
       $E$ & FLUID BC& BCtype for all elements and their faces\\
       $E$ & THERMAL BC& Thermal BCtype for all elements and their faces\\
       $1$ & PRESOLVE/RESTART & Filename of an initialized solution \\
       $K$ & INITIAL CONDITIONS & possibilities to specify IC further \\
       $K$ & OUTPUT FIELD & information that will be written to file \\
    \end{tabular}
    \caption{An overview of the different sections in .rea. $E$ is a predefined number depending on your problem
    which scales roughly as the number of elements, while $K\approx 1-25$ is user defined.}
    \label{tab:reafile}
\end{table}
%
\subsection{.usr}
This file contains a series of standard routines open for modification by the user. In addition the user is free to specify 
new routines if needed. A description of these routines are given in the Nek5000 User manual~\cite{Nek}. A list of those 
frequently used for this thesis are described below 
%routines used for this thesis are stated in table~\ref{tab:userfile}.
%
%\begin{table}
    %\centering
    %\begin{tabular}{c l}
        %Name & Description \\ \hline
        %\verb|userbc| & boundary conditions \\
        %\verb|uservp| & variable properties\\
        %\verb|userchk|& general purpose routine for checking errors etc.\\
        %\verb|usrdat2|& redifining mesh properties \\
        %\verb|usrdat3|& similar to usrdat2 \\
    %\end{tabular}
    %\caption{routines in .usr applied for this thesis.}
    %\label{tab:userfile}
%\end{table}
%
\begin{itemize}
    \item \verb|userbc| - Define the boundary conditions on the inflow-boundary, The routine is called once every timestep 
        for every node on the boundaries specified in the \verb|.rea| with a lower-case 'v' or 't'.
    \item \verb|uservp| - Define the eddy viscosity when applying LES. Only in use when $param(30)>0$ in \verb|.rea|, if this is the case 
        then this routine is called every timestep for all nodes in the domain.
    \item \verb|userchk| - Read inflow-data, and specify the output. Called once by each
        processor after every timestep and after the initialization.
    \item \verb|usrdat2| - Project the geometry onto a deformed general surface. The details of how this routine is used will be 
    specified further in chapter~\ref{implementation}. The routine is called during the initialization, right after the geometry 
    has been defined.
    \item \verb|usrdat3| - Defines the interpolation algorithm that is applied to the inflow-data, the subroutine is called 
        after \verb|usrdat2| and the reading of \verb|.rea|.
\end{itemize}
%
In addition to these routines all user-defined functions are specified in this file. The LES implementation in Nek is based
on several subroutines specified in addition to those stated above. The project onto surface routine is also implemented 
in this file.

One important thing to grasp when working with functions in \verb|.usr| is which variables that are available. 
Almost all of the subroutines include \verb|'TOTAL'| which is a file containing several other files where all the.
essential variables are defined. Sadly these variables are not well-documented and a lot time has been spent 
searching through the routines of Nek in order to understand when the variables are defined and their purpose. 
In addition to all the variables defined there are roughly 1500 different subroutines and functions specified in 
different files. Some of these are well documented through commentaries in the code itself, but there are no 
list with useful functions. The majority of these routines are not of any use to the user itself, but the search for the useful 
routines is not any simpler of that reason. In absent if this information a list of useful functions and variables that are easily 
accessible from the subroutines in \verb|.usr| are listed in Appendix~\ref{AppendixB}.
\section{Steps in the solver}
To best understand the workflow of Nek the subroutine \verb|nek_advance| in \verb|drive1.f| should be examined.
This routine includes all the steps in one iteration of the solver. The routine is adapted so that it is functional
for a number of different problems and user-settings. The most important boolean switches used in this routine are 
described in the list below 
%
\begin{itemize}
    \item ifsplit - whether the $\mathbb{P}_N-\mathbb{P}_N$ or the $\mathbb{P}_N-\mathbb{P}_{N-2}$ is to be used.
    \item iftrans - transient or steady flow.
    \item ifheat - solving for heat.
    \item ifnav - natural convection for the scalar fields (Boolean array)
    \item param(103) - activation of filtering.
\end{itemize}
%
further the routines of interests are \verb|fluid| and \verb|heat|, the solvers for N-S equations and passive scalars respectively.
Both subroutines are found in \verb|drive2.f|. The understanding of these solvers are best achieved by studying equation ~\ref{eq:NS} 
and~\ref{eq:PS}.  

%\colorbox{yellow}{what are fluidp() and heatp( )? solve for pertubated field and then project onto div-free space ? }

\colorbox{green}{How does a preconditioner work in Nek ?}

%
\section{Incompressible N-S solvers in Nek}
Nek offer several implementations depending on the mathematical formulation wanted by the user.
The most standard, and the algorithm applied in this thesis is the fractional step procedure 
described in detail in chapter~\ref{description}.


A Convection-Diffusion problem can be stated as 
\begin{align}
    M\frac{du}{dt} = Au-Cu+Mf
    \label{eq:conv-diff}
\end{align}
% 
Where $M$ and $A$ is the mass, and stiffness matrix, $f$ is the loading function and $C$ is 
the matrix corresponding to the convective term. The non-linearity is represented in the 
convective term since $C$ is dependent of $u$.
The time-derivative is discretized by a Backward difference (BDFk) scheme using solutions 
from the $k$ previous steps to extrapolate the current value. In order to gain stability 
an implicit scheme is chosen and the resulting eguation is given as 
%
OIFS ???
---------- CHECK MAKEF IN NAVIER1.F ----------------- 
\begin{align}
    \sum_{j=0}^{k}\frac{b_j}{\Delta t}Mu^{n-j+1} = Au^{n+1}-Cu^{n+1}+Mf^{n+1}
    \label{eq:conv-diff2}
\end{align}
% 
By extrapolating the convective term from the $k$ previously calculated steps the equation 
simplifies to 
%
\begin{align}
   \frac{b_0}{\Delta t}Mu^{n+1} \sum_{j=1}^{k}\frac{b_j}{\Delta t}Mu^{n-j+1} 
   = Au^{n+1}-\sum_{j=1}^{k}a_jCu^{n-j+1}+Mf^{n+1}
    \label{eq:conv-diff3}
\end{align}
% 
and finally by moving all the explicit terms to the rhs the equation left to solve is given as 
%
\begin{align}
   (\frac{b_0}{\Delta t}M-A)u^{n+1} 
   = -\sum_{j=1}^{k}(\frac{b_j}{\Delta t}M-a_jC)u^{n-j+1}+Mf^{n+1}
    \label{eq:conv-diff4}
\end{align}
% 
Notice from Section~\ref{theory} that this is equivalent to the matrix formulation of 
the Helmholtz equation.



\section{Nek5000 for complex geometries}
For complex curved geometries such as bent cylinders, spheres, ellipsoidals etc.
the user has to be able to express these surfaces analytically and write a routine
in \verb|usrdat2| that projects the points of interest onto the surface.
Even for a simple shape such as a sphere some implementation has to be done and it 
demands that the user has knowledge to Fortran77 and the structure of Nek5000.

The necessary implementation consists of two steps 
%
\begin{enumerate}
    \item determine the faces that belongs to the deformed surface
    \item project the predefined gll-points onto the deformed surface
\end{enumerate}
%
This can be done without too much work for shapes with a known analytical 
expression such as a cylinder or a sphere, but for some general CAD geometry 
it is no way to perform this projection routine. 

Many turbulent solvers does not support curved elements simply because the 
complex geometries are resolved with a sufficiently high resolution and it 
is of no interest to approximate them any better. However for a spectral element
solver it is necessary to adress this problem since the initial grid is a lot coarser
compared to equivalent settings in other solvers.

\colorbox{green}{Comment on the MOAB possibility??}

