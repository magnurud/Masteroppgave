---------- UNDERSTANDING THE LOGFILE -------------

The line 'Solving for fluid F T T' contains the three boolean vars ifsplit,iftran,ifnav

----------- BOOLEAN VARIABLES ------------
IFSPLIT ||==1: PnPn form, !=1: Pn-2Pn-2 form. "nek_advance"
IFNATC		|| natural convection, boussinesq turned on == BETAG?
IFDOIT    = .FALSE. 	|| Default in drive2.f
IFCVODE   = .false.
IFEXPLVIS = .false. || calculation of explicit stress tensor
IFTRAN   || transient flow
IFFLOW 	 || solve for fluid, pressure - velocity 
IFCHAR 	 || use characteristics for convection operator 
IFNEKNEK || NO IDEA ?? 
IFFMTIN  || If curved sides exists ? 
IFGMSH3  || velocity or stress formulation 
IFRE2 	 || the new binary reafile is created and used 
IFDFRM   || For timing purposes IFDEFORMED !! if element is deformed!! 
IFMVBD	 || If moving boundary
IFFAST 	 || if Ax is to be solved fast, IFDFRM ==1 => IFFAST = 0
LOCAL ifverbose
LOCAL icalld || Used to determine whether a subroutine has been called
----------- Variables ------------- 
istep				||	current iteration step
iostep				||	output step frecuency
time				||	TSTEP current time
timef				|| 	time at last step
timel				||	LOCAL time at last step
atime				||	LOCAL accumulated time 	
nio					||	Processor node number  
nelx				||	ZPER number of elements in x-direction 
ndim				|| number of dimensions
lglel				|| 	PARALELL vector of length lelt (mapping from local to global element index ?? )
gllel				|| 	PARALELL vector of length lelg (mapping from global to local element index ?? )
CBC					|| 3d array containing BC
ix					|| commonly used as iterator over the x-nodes within an element
kx1,kx2				|| commonly used as lower and upper bound for ix
nx1,ny1				|| similar to lx1,ly1  . Initialized in initdim , drive2.f
nx2,ny2				|| similar to lx2,ly2 (Pressure nodes) . Initialized in initdim , drive2.f
T(LX1,LY1,LZ1,LELT,LDIMT) || array containing scalars ... temperature, concentration etc. SOLN
NELV,NELT			|| number of elements , local and total ? 
IGEOM				|| 1 or 2... something to do with change in geometry ? 
BM1					|| array containing the mass in each node??
TA1					|| Array used to store convectional contribution of a scalar, TA2,TA3 the same,induct.f SCRUZ

------TSTEP----------
DT 					|| timestep
DTLAG				|| array containing the preevious 10 timesteps
BD 					|| array containing upto 10 backward difference coeffs
AB 					|| array containing upto 10 extrapolation coeffs (Adam-Bash...)
NBDINP			|| param(27), TORDER, temporal discretization order, initialized in drive2.f
NBD 				|| temporal discretization order, including initial developement.
DTINVM			|| 1/DT
------curved elements------
CCURVE(12,lelt)    || array containing curved side character. , INPUT
CURVE(12,6,LELT)   || array containing curved side information, INPUT
IFDFRM(LELT)	   || array of booleans regarding element structure.. angle=90 or not ? || COMMON/FASTMD
arcsrf(xml,yml,zml,nxl,nyl,nzl,ie,isid) || imposing circle geometry. 
sphsrf(xml,yml,zml,iface,ie,nxl,nyl,nzl,work) || imposing sperical geometry
rdcurve 			|| subroutine for reading curved side data
bin_rd1(ifbswap)	|| reading mesh, curves, bc. called from subroutine readat for .re2 files.
gengeom(igeom)		|| Generate geometry data, drive2.f
geom_reset(icalled)	|| reGenerate geometry data, ic.f
geom1 (xm3,ym3,zm3) || routine to generate all elemental geometric data for mesh 1 coeff.f
glmapm1				|| routine to generate mapping data based on GLL , coeff.f
volume 				|| Compute the volume coeff.f
setinvm 			|| Inverts the mass matrix coeff.f 
setdef				|| Set up deformed element logical switches, genxyz.f KEY FUNCTION!!! 


--------------------------------------------------------------------------------------
----- local variables used when interpolating values and writing to file htps-procedure----
fieldin			|| input field(s) to interpolate (lelt*lxyz,nfld)
nfld				|| number of fields in fieldin
pts					|| packed list of interpolation points pts:=[x(1)...x(n),y(1)...y(n),z(1)...z(n)]
n						|| local number of interpolation points
ifto				|| transpose output (n,nfld)^T = (nfld,n) 
itpts				|| find interpolation points 
ih					|| interpolation handle
fieldout    || packed list of interpolated values (n,nfld)
---------- Functions ------------------------------------- 
XM1(ix,iy,iz,e) 	Provides the x-position of node nr (ix,iy,iz) in element e.
avg1(avg_var,curr_var,alpha,beta,n,'avg_var',ifverbose)	Calculating average of var. alpha and beta are the weights, n is the length of the vector		navier5.f
avg2 		Basically the same but for squared variables.
avg3 		average of a variable that is a product of two separate variables.
avg_all		averaging all standard variables... navier5.f
rzero(vec,n) 	fill vec with length n full of zeroes
get_exyz 			get the element position in each direction of a given element
hpts() 				output for some points given in htps.in postpro.f
hpts_out(fieldout,nflds,nfldm,npoints,nbuff) 
facind(KX1,KX2,KY1,KY2,KZ1,KZ2,NX,NY,NZ,IFACE)   Making sure the limits kx1,kx2... are correct when iterating over face IFACE.
userbc(IX,IY,IZ,IFACE,IEG) 	imposing bc for node (ix,iy,iz) on face iface of element IEG
NEKASGN (IX,IY,IZ,IEL) Updating the common variables in NEKUSE for the given node NOTE: Is performed before every userbc call!
copy(a,b,n) copies the n first elements in b to a. a,b = real 
settolv()	|| Set tolerance for velocity vector
convop(conv,fi)	|| compute the convective term of a scalar
blank(A,N) || set all elements in a character array equal ''
FNC(ETA) 	|| Should return something close to zero if eta is small. Has to do with sphere genxyz.f
lagmass 	|| Lag the mass matrix


------------- Files --------------- 
htps.in 		A file that defines certain output points, on the format:
N
X1 Y1 Z1
X2 Y2 Z2
.....
XN YN ZN

------------- TIPS ---------------
When defining curves... a minus sign could imply reducing the precision.

say t(lx,ly) is to be iterated in a function. often the first element is 
passed as t(1,1) or simply t along with n = lx*ly


------- Q's for THG ------------
icalld ? local variable in many scripts... 
igeom ? Moving mesh

------ Common mistakes ------ 
The lelt variable is not large enough
Remember to set all parts in icem to PLOAD, what went wrong in test-case
Relocation truncated to fit. ==> lx1*lelt is too big!! 
